"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const type_guards_1 = require("../utils/type-guards");
const token_pos_1 = __importDefault(require("./utils/token-pos"));
const supportedDiagnostics = new Set([
    // TS2339: Property '{0}' does not exist on type '{1}'.
    2339,
    // TS2571: Object is of type 'unknown'.
    2571,
]);
const addConversionsPlugin = {
    name: 'add-conversions',
    run({ fileName, sourceFile, text, options, getLanguageService }) {
        // Filter out diagnostics we care about.
        const diags = getLanguageService()
            .getSemanticDiagnostics(fileName)
            .filter(type_guards_1.isDiagnosticWithLinePosition)
            .filter((diag) => supportedDiagnostics.has(diag.code));
        const result = typescript_1.default.transform(sourceFile, [addConversionsTransformerFactory(diags, options)]);
        const newSourceFile = result.transformed[0];
        if (newSourceFile === sourceFile) {
            return text;
        }
        const printer = typescript_1.default.createPrinter();
        return printer.printFile(newSourceFile);
    },
};
exports.default = addConversionsPlugin;
const addConversionsTransformerFactory = (diags, { anyAlias }) => (context) => {
    const { factory } = context;
    const anyType = anyAlias
        ? factory.createTypeReferenceNode(anyAlias)
        : factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword);
    let nodesToConvert;
    return (file) => {
        nodesToConvert = new Set(diags
            .map((diag) => {
            const token = token_pos_1.default(file, diag.start);
            switch (diag.code) {
                case 2339:
                    if (!typescript_1.default.isPropertyAccessExpression(token.parent)) {
                        return null;
                    }
                    return token.parent.expression;
                case 2571:
                    return token;
                default:
                    // Should be impossible.
                    return null;
            }
        })
            .filter((node) => node !== null));
        return typescript_1.default.visitNode(file, visit);
    };
    function visit(origNode) {
        const needsConversion = nodesToConvert.has(origNode);
        const node = typescript_1.default.visitEachChild(origNode, visit, context);
        if (!needsConversion) {
            return node;
        }
        return factory.createAsExpression(node, anyType);
    }
};
//# sourceMappingURL=add-conversions.js.map